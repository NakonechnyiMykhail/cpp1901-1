/*=====================================================
 * Перевод двоичного кода в десятичный методом сложения
 * Создал: xXDima212DimaXx
 *
 * Лицензия: Свободный доступ и модификация
 *
 * Как это работает?
 *
 * Создается массив данных (пользовательские данные),
 * в который пользователь заносит двоичное значение.
 * Затем создается переменная кратная 2 (ее значение
 * зависит от длины введенных данных. Например для
 * 1 байта это 128). Затем если первая цифра данных
 * равна 1, к конечному значению прибавляется
 * значение этой переменноя, и наоборот если первая
 * цифра равна 0, то прибавления не происходит.
 * Затем та переменная (кратная 2) делится на 2 и
 * действие повторяется, только уже проверяется вторая
 * цифра в двоичном значении. Цикл выполняется пока
 * переменная, которая кратна 2 не достигает значения 1
 * и пока в двоичных данных не закончились цыфры для
 * проверки (их количество равно размеру массива с
 * пользовательскими данными). После этого полученное
 * значение выводиться на экран.
 *===================================================*/

#include <iostream>
#include <cstdlib>
#include <limits>
#include <cstring>

int convert(char val[]);

int main (void) {
    // Значение, которое вводит пользователь (1 байт)
    char value[8] = {};

    // Для проверки длины (Debug)
    // char vb[] = "";

    // Запрос пользовательского ввода
    std::cout << "Enter 1 byte: ";
    std::cin >> value;

    // Debug
    // if (vb.length() == 8) {
    //     value = vb;
    // } else {
    //     std::cout << "Incorect length of data. You can use only 8 digits!" << std::endl;
    //     return 1;
    // }

    // Исправление бага при вводе неверного типа данных
    if ((std::cin.fail() == 0)) {
        // Если пользователь ввел правильный тип данных, продолжаем выполнение
    } else {
        // Если тип данных некорректный, то завершаем программу, выдав ошибку
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        std::cout << "Incorect type of data. Value \"" << value << "\" not allowed. You can use only 0 or 1!" << std::endl;
        return 1;
    }

    for (int g = 0; g < sizeof(value); g++) {
        if ((value[g] == '0') || (value[g] == '1')) {

        } else {
            std::cout << "Incorect type of data. Value \"" << value << "\" not allowed. You can use only 0 or 1!" << std::endl;
            return 1;
        }
    }

    // Debug
    // std::cout << value << std::endl;

    // Вызов условной функции, которая проверяет значение введенные данные и выводит результат на экран
    std::cout << "Decoded value: " << convert(value) << std::endl;

    return 0;
}

// Условная функция, которая проверяет значение переменной val
int convert(char val[]) {
    // Debug
    // std::cout << val << std::endl;

    // R - конечное значение, которое выведет программа
    int r = 0;

    // J для откладки. По желанию можно удалить и использовать val[int] в проверочном условии
    int j = 0;

    // plus - переменная, помогающая вычислить значение r (см. код ниже)
    int plus = 256;

    // Цикл проверки. Выполняется n-ое кол-во раз, где n - число Бит (1 Байт = 8 Бит)
    for (int i = 0; i < sizeof(val); i++) {
        /*=====================================================
         * Раскоментировать если программа работает неправильно
         * (Режим откладки)
         * std::cout << "[" << i << "]" << "\t";
         * std::cout << val[i] << "\t";
         *===================================================*/

        // J для откладки. По желанию можно заменить на val[int] в проверочном условии
        j = val[i];

        /*=====================================================
         * Раскоментировать если программа работает неправильно
         * (Режим откладки)
         * std::cout << "Debug j: " << j << "\t";
         * std::cout << "Debug j - 48: " << (j - 48) << "\t";
         *===================================================*/

        // Необходимо для расшифровки двоичного кода методом сложения
        plus = plus/2;

        // Проверка
        if ((j - 48) == 1) {
            r = r + plus;

            // Debug
            // std::cout << "\t 1\t" << r << " Debug plus: " << plus << std::endl;
        } else {
            // Debug
            // std::cout << "\t 0\t" << r << " Debug plus: " << plus << std::endl;
        }

    }

    // Возврат результата выполнения программы
    return r;
}